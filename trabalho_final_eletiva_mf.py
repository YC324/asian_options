# -*- coding: utf-8 -*-
"""Trabalho Final - Eletiva MF

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B7GGFlN2F9IuEKxZvAhXqwgyqcXdJfjU
"""

import streamlit as st
import numpy as np
import scipy.stats as si

# Função para calcular o preço de uma opção Call no modelo Black-Scholes
def black_scholes_call(S, K, r, T, v):
    d1 = (np.log(S / K) + (r + 0.5 * v ** 2) * T) / (v * np.sqrt(T))
    d2 = d1 - v * np.sqrt(T)
    call_price = S * si.norm.cdf(d1) - K * np.exp(-r * T) * si.norm.cdf(d2)
    return call_price

# Função para calcular o preço de uma opção Put no modelo Black-Scholes
def black_scholes_put(S, K, r, T, v):
    d1 = (np.log(S / K) + (r + 0.5 * v ** 2) * T) / (v * np.sqrt(T))
    d2 = d1 - v * np.sqrt(T)
    put_price = K * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)
    return put_price

# Função para calcular o preço de uma opção asiática geométrica
def geometric_asian_option(S, K, r, T, v, tipo="Call"):
    adj_sigma = v * np.sqrt((2 * T * 252 + 1) / (6 * (T * 252 + 1)))  # Ajusta a volatilidade
    rho = r - (v**2) / 2 + (adj_sigma**2) / 2
    d1 = (np.log(S / K) + (rho + 0.5 * adj_sigma**2) * T) / (adj_sigma * np.sqrt(T))
    d2 = d1 - adj_sigma * np.sqrt(T)
    if tipo == "Call":
        price = np.exp(-r * T) * (S * np.exp(rho * T) * si.norm.cdf(d1) - K * si.norm.cdf(d2))
    else:  # Put
        price = np.exp(-r * T) * (K * si.norm.cdf(-d2) - S * np.exp(rho * T) * si.norm.cdf(-d1))
    return price

# Função para calcular o preço de uma opção binária (simples)
def binary_option_price(S, K, r, v, T, tipo="Call"):
    d2 = (np.log(S / K) + (r - 0.5 * v**2) * T) / (v * np.sqrt(T))
    if tipo == "Call":
        price = np.exp(-r * T) * si.norm.cdf(d2)
    else:  # Put
        price = np.exp(-r * T) * (1 - si.norm.cdf(d2))
    return price

# Configuração da interface Streamlit
def main():
    st.title("Calculadora de Opções")
    st.write("Calcule o preço de uma opção usando diferentes modelos de precificação.")

    # Escolha do método de cálculo
    calc_method = st.selectbox("Escolha o método de cálculo",
                                ("Black-Scholes", "Opção Asiática (Geométrica)", "Opção Binária"))

    # Escolha do tipo de opção
    option_type = st.selectbox("Escolha o tipo de opção", ("Call", "Put"))

    # Entradas do usuário
    S = st.number_input("Preço do ativo subjacente (S)", value=100.0, format="%.2f")
    K = st.number_input("Preço de exercício (K)", value=100.0, format="%.2f")
    r = st.number_input("Taxa de juros livre de risco (r)", value=0.05, format="%.2f")
    T = st.number_input("Tempo até o vencimento (T) em anos", value=1.0, format="%.2f")
    v = st.number_input("Volatilidade anualizada (v)", value=0.2, format="%.2f")

    # Botão para calcular
    if st.button("Calcular"):
        if calc_method == "Black-Scholes":
            if option_type == "Call":
                price = black_scholes_call(S, K, r, T, v)
                st.success(f"O preço da opção Call é: R${price:.2f}")
            elif option_type == "Put":
                price = black_scholes_put(S, K, r, T, v)
                st.success(f"O preço da opção Put é: R${price:.2f}")

        elif calc_method == "Opção Asiática (Geométrica)":
            if option_type == "Call":
                price = geometric_asian_option(S, K, r, T, v, tipo="Call")
                st.success(f"O preço da opção asiática geométrica Call é: R${price:.2f}")
            elif option_type == "Put":
                price = geometric_asian_option(S, K, r, T, v, tipo="Put")
                st.success(f"O preço da opção asiática geométrica Put é: R${price:.2f}")

        elif calc_method == "Opção Binária":
            if option_type == "Call":
                price = binary_option_price(S, K, r, v, T, tipo="Call")
                st.success(f"O preço da opção binária Call é: R${price:.2f}")
            elif option_type == "Put":
                price = binary_option_price(S, K, r, v, T, tipo="Put")
                st.success(f"O preço da opção binária Put é: R${price:.2f}")

# Executa a interface principal
if __name__ == "__main__":
    main()